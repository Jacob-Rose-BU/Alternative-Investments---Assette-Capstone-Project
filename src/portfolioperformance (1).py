# -*- coding: utf-8 -*-
"""PORTFOLIOPERFORMANCE

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kv9S7lPYupQLU8oBzRWoeWRpgMuP5FzA

# Portfolio Performance Table

The Portfolio Performance table captures calculated investment returns for each portfolio over defined reporting periods. It records daily performance values alongside benchmark returns and alpha, enabling direct comparison of portfolio results against a chosen benchmark. This table serves as a core fact sheet input, summarizing how a portfolio has performed over time in a standardized, auditable format.

**Columns Modified From Assette:**

- PORTFOLIOCODE: Portfolio identifier, from portfolio configuration.

- HISTORYDATE: Reporting date (end of performance period).

- CURRENCYCODE: Currency code for returns (e.g., 'USD').

- CURRENCY: Human-readable currency name (matches CURRENCYCODE).

- PERFORMANCECATEGORY: Classification of performance (e.g., 'Total Return').

- PERFORMANCETYPE: Always set to defined PERFORMANCE_TYPE label (e.g., 'Holdings-Based').

- PERFORMANCEPERIOD: Label for the performance period (e.g., 'YTD', '1M', '3M', '1Y').

- PERFORMANCEFREQUENCY: Frequency of return calculation (hardcoded as 'Daily').

- PORTFOLIOPERFORMANCE: Portfolio return for the period, rounded to 6 decimals (None if NaN).

- BENCHMARKRETURN: Benchmark return for the same period, rounded to 6 decimals (None if NaN).

**Columns Created from Yfinance:**

- BENCHMARKCODE – Identifier for the benchmark index (e.g., SP500ESG).

- ALPHA – Holdings-based alpha = Portfolio return – Benchmark return.

# Configuration & Inputs

What: Set up periods, universe, portfolios (rules-based), and benchmark. Uses PRICE-BASED math (no holdings/NAV)

Why: Reproducible, audit-friendly when you don't have NAV or dated holdings snapshots.

Output of this block:
 - PERIODS: list of (label, start_ts, end_ts)
 - PORTFOLIOS: dict {PORTFOLIOCODE: [tickers...]}
 - BENCHMARK_TICKER: string ('^SPESG' SP500 ESG)
"""

# 1) CONFIG + INPUTS
from datetime import datetime
import pandas as pd
import numpy as np
import yfinance as yf

# user-configurable toggles
PREFER_ADJ_CLOSE = True
PERFORMANCETYPE_LABEL = "Price-Based (Adj Close, Chain-Linked)"
PERFORMANCECATEGORY = "Total Return"
CURRENCY = "USD"
MIN_DAYS = 5                # Skip a period if fewer trading days than this
TODAY = pd.Timestamp.today().normalize()

# Reporting periods (adjust as needed)
PERIODS = [
    ("1M", TODAY - pd.DateOffset(months=1), TODAY),
    ("3M", TODAY - pd.DateOffset(months=3), TODAY),
    ("YTD", pd.Timestamp(TODAY.year, 1, 1), TODAY),
    ("1Y", TODAY - pd.DateOffset(years=1), TODAY),
]

# Example universe and model portfolios
UNIVERSE = ["AAPL","MSFT","NVDA","AMZN","META","GOOGL","TSLA","AVGO","COST","PEP","JPM","WMT","XOM","LLY","UNH"]
PORTFOLIOS = {
    "P001": ["AAPL","MSFT","NVDA","AMZN","META"],
    "P002": ["GOOGL","TSLA","AVGO","COST","PEP"],
    "P003": ["JPM","WMT","XOM","LLY","UNH"],
}
BENCHMARK_TICKER = "^SPESG"  # SP500 ESG

def _download_prices_yf(tickers, start, end):
    """
    Download OHLCV + corporate actions for a set of tickers.
    Returns a yfinance-style wide DataFrame with MultiIndex columns:
      level 0: 'Adj Close', 'Close', 'Dividends', 'Stock Splits', ...
      level 1: ticker symbol
    Handles single-ticker case by building a MultiIndex.
    """
    # yfinance accepts list or string; keep as list for consistency
    tickers = list(sorted(set(tickers)))
    df = yf.download(tickers, start=start, end=end, interval="1d", progress=False, auto_adjust=False)

    if isinstance(df.columns, pd.MultiIndex):
        return df

    # Single-ticker case: build MultiIndex columns
    tkr = tickers[0]
    # Keep common fields if they exist
    fields = [c for c in ["Adj Close", "Close", "Dividends", "Stock Splits"] if c in df.columns]
    if not fields:
        # Fallback: treat whatever is there as Close
        df = df.rename(columns={df.columns[0]: "Close"})
        fields = ["Close"]

    tuples = [(f, tkr) for f in fields]
    df = df[fields].copy()
    df.columns = pd.MultiIndex.from_tuples(tuples, names=[None, None])
    return df

def _best_price_panel(prices_wide, prefer_adj=True):
    """
    Choose 'Adj Close' if available, else 'Close'.
    """
    level0 = prices_wide.columns.get_level_values(0)
    if prefer_adj and "Adj Close" in level0:
        return prices_wide["Adj Close"].copy()
    return prices_wide["Close"].copy()

def _daily_return_panel(prices_wide, prefer_adj=True):
    """
    Build DAILY RETURNS per ticker from the chosen price panel.
    """
    px = _best_price_panel(prices_wide, prefer_adj=prefer_adj).astype(float)
    return px.pct_change()

"""# Gather Historical Prices

What: Download prices once for the full window you need, build daily return matrices (Adj Close → fallback → Close), and a chain-link helper.

Why : Single-source of truth for returns; consistent handling.

Outputs:
  - prices_df: yfinance multi-index DataFrame (all tickers)
  - bench_df : yfinance DataFrame for the benchmark
  - helper fns: extract daily returns for any window
"""

# 2) PRICE DOWNLOAD + RETURN HELPERS
def _download_prices_yf(tickers, start, end):
    """
    Download OHLCV + corporate actions for a set of tickers.
    Returns a yfinance-style wide DataFrame with MultiIndex columns:
      first level: 'Adj Close', 'Close', 'Dividends', 'Stock Splits', ...
      second level: ticker symbol
    """
    df = yf.download(sorted(list(set(tickers))), start=start, end=end, interval="1d", progress=False, auto_adjust=False)
    # For single ticker, yfinance returns single-level columns. Normalize to MultiIndex.
    if not isinstance(df.columns, pd.MultiIndex):
        df.columns = pd.MultiIndex.from_product([["Close"], df.columns])
    return df

def _best_price_panel(prices_wide, prefer_adj=True):
    """
    Choose the best price panel ('Adj Close' preferred; else 'Close').
    Returns a wide price DataFrame: index=Date, columns=tickers
    """
    level0 = prices_wide.columns.get_level_values(0)
    if prefer_adj and "Adj Close" in level0:
        return prices_wide["Adj Close"].copy()
    return prices_wide["Close"].copy()

def _daily_return_panel(prices_wide, prefer_adj=True):
    """
    Convert the chosen price panel to DAILY RETURNS per ticker.
    Simple pct_change; (if you need dividend/split approximation, we can extend).
    """
    px = _best_price_panel(prices_wide, prefer_adj=prefer_adj).astype(float)
    return px.pct_change()

def _chain_link(daily_series: pd.Series) -> float:
    """
    Chain-link daily returns into a period return.
    """
    if daily_series is None or daily_series.empty:
        return np.nan
    return (1.0 + daily_series.fillna(0)).prod() - 1.0

# --- Download once for the union of all tickers across all periods ---
_all_tickers = set().union(*PORTFOLIOS.values())
min_start = min(s for _, s, _ in PERIODS)
max_end = max(e for _, _, e in PERIODS)
prices_df = _download_prices_yf(_all_tickers, start=min_start, end=max_end)

# Benchmark prices once
bench_df = _download_prices_yf([BENCHMARK_TICKER], start=min_start, end=max_end)

"""# Price Based Securities

What: For each (portfolio, period), compute:
  -daily portfolio return = weighted sum of daily sec returns
  -chain-link to the period return
  -benchmark return over identical dates
  -alpha = portfolio - benchmark

Why : Fact-sheet friendly, reproducible, and no holdings/NAV needed.

Output: PORTFOLIOPERFORMANCE DataFrame ready for CSV/Snowflake.
"""

# 3) PERIOD ENGINE (PRICE-BASED, NO HOLDINGS)
# ----------------------------------------------------------

# ==========================================================
def _equal_weights(n):
    return np.repeat(1.0/n, n)

def _portfolio_period_return(daily_ret_panel, tickers, start, end, weights=None):
    """
    Slice daily return matrix to [start:end], keep requested tickers that exist,
    renormalize weights to surviving tickers, return chain-linked period return.
    """
    # Align window
    dr = daily_ret_panel.loc[(daily_ret_panel.index >= start) & (daily_ret_panel.index <= end)]
    # Keep available tickers only
    cols = [t for t in tickers if t in dr.columns]
    dr = dr[cols].dropna(how="all")
    if dr.shape[0] < MIN_DAYS or dr.shape[1] == 0:
        return np.nan
    # Weights (equal-weight default)
    if weights is None:
        w = _equal_weights(dr.shape[1])
    else:
        w = np.array(weights, dtype=float)
        if len(w) != len(cols):
            w = _equal_weights(dr.shape[1])  # mismatch fallback
        s = w.sum()
        if s == 0: w = _equal_weights(dr.shape[1])
        else: w = w / s
    # Daily portfolio return and chain-link
    port_daily = (dr * w).sum(axis=1)
    return _chain_link(port_daily)

def _benchmark_period_return(bench_prices, start, end):
    """
    Compute benchmark period return from prices over the same window.
    Uses the same price preference (Adj Close -> Close).
    """
    sub = bench_prices.loc[(bench_prices.index >= start) & (bench_prices.index <= end)]
    if sub.empty:
        return np.nan
    bench_prices_panel = _best_price_panel(sub, prefer_adj=PREFER_ADJ_CLOSE)
    bench_daily = bench_prices_panel.iloc[:, 0].astype(float).pct_change()
    return _chain_link(bench_daily)

# Build the daily return panel once from prices
daily_ret_panel = _daily_return_panel(prices_df, prefer_adj=PREFER_ADJ_CLOSE)

rows = []
for label, start, end in PERIODS:
    for pcode, tickers in PORTFOLIOS.items():
        r_port = _portfolio_period_return(daily_ret_panel, tickers, start, end, weights=None)
        r_bench = _benchmark_period_return(bench_df, start, end)
        rows.append({
            "PORTFOLIOCODE": pcode,
            "HISTORYDATE": end.date(),
            "CURRENCYCODE": CURRENCY,
            "CURRENCY": CURRENCY,
            "PERFORMANCECATEGORY": PERFORMANCECATEGORY,
            "PERFORMANCETYPE": PERFORMANCETYPE_LABEL,
            "PERFORMANCEPERIOD": label,
            "PERFORMANCEFREQUENCY": "Daily",
            "PORTFOLIOPERFORMANCE": None if pd.isna(r_port) else round(float(r_port), 6),
            "BENCHMARKCODE": BENCHMARK_TICKER,
            "BENCHMARKRETURN": None if pd.isna(r_bench) else round(float(r_bench), 6),
            "ALPHA": None if (pd.isna(r_port) or pd.isna(r_bench)) else round(float(r_port - r_bench), 6),
        })

PORTFOLIOPERFORMANCE = pd.DataFrame(rows)
print("PORTFOLIOPERFORMANCE preview:")
PORTFOLIOPERFORMANCE

"""#Exports

What: Save CSV, and add simple QA checks so a new analyst can spot issues (NaNs, too-few days, misaligned dates).

Why : Production hygiene without adding lots of code.
"""

# 4) EXPORTS + GUARDRAILS
# ----------------------------------------------------------

# ==========================================================
# Save
PORTFOLIOPERFORMANCE.to_csv("PORTFOLIOPERFORMANCE_price_based.csv", index=False)

# Quick QA flags
qa = PORTFOLIOPERFORMANCE.copy()
qa["MISSING_ANY"] = qa[["PORTFOLIOPERFORMANCE", "BENCHMARKRETURN", "ALPHA"]].isna().any(axis=1)
qa_summary = qa.groupby(["PERFORMANCEPERIOD", "MISSING_ANY"]).size().reset_index(name="rows")
print("\nQA summary (rows with any missing metrics):")
print(qa_summary)